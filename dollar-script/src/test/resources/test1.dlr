testPipe='class:me.neilellis.dollar.script.TestPipe'

c={
"test" : 1,
"test2" : [1,2,3,{"foo":"bar"}]} | $testPipe

f={1;2;3;4;}
>> $f

multiline={
"Hello "
"World"
}

>> $multiline
>> $c
>> $c.test2

a="Hello";
b="World";

>> $a;

a="Goodbye";
d= a.doesntExist ?: 2;

//Assert d == 2

=> $d == 2

>> $d == 2 -> "It's True !!!";

>> $d;

>> $a;
>> $c ;

>> [$a, $b, $c] ;

$c > "/tmp/test2.out" ;
d < "/etc/ssh_config" ;

//>> $d ;

//>> {"test" : 1, "test2" : 2} | 'mvn:me.neilellis.dollar.script.TestPipe:me.neilellis:dollar-script:0-SNAPSHOT'

=> [1,2,3]  == [1,2,3] ;
=> [1,2,3] != [4,2,3] ;
=> [1,2,3] + 4 == [1,2,3,4];
=> [1,2,3,4] - 4 == [1,2,3];

=> [] + 1 == [1] ;
=> [1] + [1] == [1,[1]];
=> [1] + 1 == [1,1];
=> 1 + 1 == 2;
=> 1 + 1 + 1 == 3

=> 2 - 1 == 1;



// = (assignment) normally forces immediate evaluation of the RHS
// however := is the lambda assignment and does not, thus creating a
// lambda style expression


lamval=1
lambda2 := $lamval

lambda := ( ( $lamval )  + $lamval )
notlambda = ( ( $lamval )  + $lamval )

lamval= 7

lamval2= 23

//The simplest possible lambda (serves no purpose!)
=> 1 == 1

=> 1 == <> 1

=> <> 1 == 1

//Since the lambda shares the scope of when it was declared this should be 14 not 2
=> $lambda == 14
=> $notlambda == 2

//And this is the single $lamval syntax from earlier
=> $lambda2 == 7


//Now we test levels of indirection
delayName := ("lamval" + $lamval)
lamval=5
lamval5=13

//Did you follow that crazyness :-) Don't do this at home!

//Lambda variable resolution >>! - notice the two levels of indirection here - yeah edge case :-)
=> $$delayName == 13


// <> forces immediate evaluation, the value lock symbol
// otherwise values are assumed to be lambdas and are lazily evaluated

function := [
    >> "Function start",  //This is displayed during evaluation, return is void
    <> $lamval,  //locked into the current value at definition (i.e. 5)
       $lamval,  //lazy evaluated, will take the value when the whole block is evaluated
       $1      //A value to be passed in via  a pipe $1 is a special variable
]


lamval = "fred"

!! ([1,2,3] | $function)
=> ([1,2,3] | $function) ==  [ 5, "fred", [1, 2, 3] ]

removeWorld := ($1 - "World")

=> (["Hello", "World"] | $removeWorld) == ["Hello"]
=> (["Goodbye", "World"] | $removeWorld) == ["Goodbye"]

testParams := ($2 + " " + $1)

=> $testParams ("Hello", "World") == "World Hello"

//TODO
#marinaVideos <+ https://itunes.apple.com/search?term=Marina+And+The+Diamonds&entity=musicVideo

#Filter operator (applies jquery style or jxpath style filter) - use this to get video names

#Iteration pipe 1|* which does the same as each == toList().forEach(Pipeable pipe) - create that also

// 1|* - splitter - the pipe is applied to each part of the list
// *|* - fork join ? - list is split, each part passed to the pipe and returned as a list again
// *|1 - join      - list is split all parts passed to pipe and joined using the pipe
// 1|1 - normal pipe





